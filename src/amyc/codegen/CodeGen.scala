package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{And => AmyAnd, Call => AmyCall, Div => AmyDiv, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm.{Instructions, _}
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the functionality for the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to their index in 
    // the wasm local variables, and a LocalsHandler which will generate fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case IntLiteral(i) => i2c(Const(i))
        case BooleanLiteral(b) => if(b) i2c(Const(1)) else i2c(Const(0))
        case UnitLiteral() => i2c(Const(0))
        case StringLiteral(str) => mkString(str)

        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem

          // Short circuiting
        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End

        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s

        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")

        case Neg(e) => cgExpr(e) <:> Const(-1) <:> Mul

        case Not(e) => cgExpr(e) <:> Eqz

        case Error(msg) => cgExpr(msg) <:> Call("Std_printString") <:> Unreachable

        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)

        case Ite(cond, thenn, elze) => cgExpr(cond) <:> If_i32 <:>
          cgExpr(thenn)<:> Else <:> cgExpr(elze) <:> End
          
          // Update
        case While(cond, body) => 
          val nextLabel = getFreshLabel()
          val startLabel = getFreshLabel()
          val bodyLabel = getFreshLabel()
          Block(nextLabel) <:> Loop(startLabel) <:> Block(bodyLabel) <:>
          cgExpr(cond) <:> If_void <:> Br(bodyLabel) <:> Else <:> Br(nextLabel) <:> End <:>
          End <:> cgExpr(body) <:> Br(startLabel) <:> End <:> End <:> Const(1)

        case Let(df, value, body, _) => {
          val pt = lh.getFreshLocal()
          cgExpr(value) <:> SetLocal(pt) <:> cgExpr(body)(locals + (df.name -> pt), lh)
        }

        case Variable(name) => GetLocal(locals(name))

          // Update
        case Reassign(name, newValue) => {
          cgExpr(newValue) <:> SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

          // Update: Reassignment operatos "id += value" is the same as "id = id + value"
        case PlusEquals(name, value) => {
          GetLocal(locals(name)) <:> cgExpr(value) <:> Add <:>
            SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

        case MinusEquals(name, value) => {
          GetLocal(locals(name)) <:> cgExpr(value) <:> Sub <:>
            SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

        case TimesEquals(name, value) => {
          GetLocal(locals(name)) <:> cgExpr(value) <:> Mul <:>
            SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

        case DivEquals(name, value) => {
          GetLocal(locals(name)) <:> cgExpr(value) <:> Div <:>
            SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

        case ModEquals(name, value) => {
          GetLocal(locals(name)) <:> cgExpr(value) <:> Rem <:>
            SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

        case ConcatEquals(name, value) => {
          GetLocal(locals(name)) <:> cgExpr(value) <:> Call("String_concat") <:>
            SetLocal(locals(name)) <:> GetLocal(locals(name))
        }

        case AmyCall(qname, args) => {
          table.getFunction(qname) match {
            case Some(FunSig(_, _, owner)) => cs2c(args.map(a => cgExpr(a))) <:> Call(fullName(owner, qname))
            case None => {
              table.getConstructor(qname) match {
                case Some(ConstrSig(_, _, index)) => {
                  val argsWithIndex = args.zipWithIndex
                  val ptr = lh.getFreshLocal()
                  // Save memory boundary
                  GetGlobal(memoryBoundary) <:> SetLocal(ptr) <:>
                  // Adt allocate
                  GetGlobal(memoryBoundary) <:> adtField(args.size) <:>
                  // index of constructor to memory boundary
                  SetGlobal(memoryBoundary) <:> GetLocal(ptr) <:> Const(index) <:> Store <:>
                  // Correct offset in memory to place field
                  argsWithIndex.map(a => GetLocal(ptr) <:> adtField(a._2) <:> cgExpr(a._1) <:> Store) <:>
                    GetLocal(ptr)
                }
                  //Should not arrive here, otherwise let compiler crash gracefully
              }
            }
          }
        }


        case Match(scrut, cases) => {
          val cgScrut = cgExpr(scrut)
          val scrutPtr = lh.getFreshLocal()

          var newLocals = locals

          def matchAndBind(pattern: Pattern, scrutPtr: Int): Code = {

            pattern match {
              case WildcardPattern() => GetLocal(scrutPtr) <:> Drop <:> Const(1)
              case IdPattern(name) => {
                val idPatPtr = lh.getFreshLocal()
                newLocals = newLocals + (name -> idPatPtr)
                GetLocal(scrutPtr) <:> SetLocal(idPatPtr) <:> Const(1)
              }
              case LiteralPattern(lit) => GetLocal(scrutPtr) <:> cgExpr(lit) <:> Eq
              case CaseClassPattern(constr, args) => {
                val argsWithIndex = args.zipWithIndex
                val constrIndex = table.getConstructor(constr) match {
                  case Some(ConstrSig(_, _, index)) => index
                  // Should not arrive here, otherwise let compiler crash gracefully
                }
                
                if(args.isEmpty){
                  // Only check constructor index
                  GetLocal(scrutPtr) <:> Load <:> Const(constrIndex) <:> Eq <:> If_i32 <:> Const(1) <:>
                    Else <:> Const(0) <:> End
                } else {
                  val (argsHead, argsTail) = (argsWithIndex.head, argsWithIndex.tail)
                  val ptr = lh.getFreshLocal()
                  // First check constructor index
                  GetLocal(scrutPtr) <:> Load <:> Const(constrIndex) <:> Eq <:> If_i32 <:>
                    GetLocal(scrutPtr) <:> adtField(argsHead._2) <:> Load <:> SetLocal(ptr) <:>
                    // matchAndBind first argument
                    matchAndBind(argsHead._1, ptr) <:> If_i32 <:> Const(1) <:> Else <:> Const(0) <:> End <:>
                    cs2c(argsTail.map(a => {
                      val scrutNewPtr = lh.getFreshLocal()
                      GetLocal(scrutPtr) <:> adtField(a._2) <:> Load <:> SetLocal(scrutNewPtr) <:>
                        matchAndBind(a._1, scrutNewPtr) <:> If_i32 <:> Const(1) <:> Else <:> Const(0) <:>
                        End <:> And
                    })) <:> Else <:> Const(0) <:> End
                }
              }
            }
          }
          val scrutCode = cgScrut <:> SetLocal(scrutPtr)
          val (casesHead, casesTail) = (cases.head, cases.tail)
          val mainCode = matchAndBind(casesHead.pat, scrutPtr) <:> If_i32 <:> cgExpr(casesHead.expr)(newLocals, lh) <:>
            cs2c(casesTail.map{
              case MatchCase(pat, expr) => {
                // reset case Locals
                newLocals = locals
                Else <:> matchAndBind(pat, scrutPtr) <:> If_i32 <:> cgExpr(expr)(newLocals, lh)
              }
            })
          val matchErrorCode = Else <:> mkString("Match error!") <:> Call("Std_printString") <:> Unreachable
          val endFinishings = cs2c(List.fill(cases.size)(End))
          scrutCode <:> mainCode <:> matchErrorCode <:> endFinishings
        }

      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
